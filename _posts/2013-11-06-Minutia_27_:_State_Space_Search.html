
--
layout: minutia-27
title: Minutia-27: State Space Search
--
<!--<!DOCTYPE html>
<html>
  <body>-->
    <h1> Minutia #27, Period 6 </h1>
    <h3> Focus: State space search.</h3>
    <h4> Jared Yuen </h4>
    <h4> Date: 06 November 2013 </h4>

    <h3>Summary:</h3>
    <p>
      Class started with a quick review of Depth-first search and Breadth-frist search, as well as a demo of both.
      With a recursive Depth-first search you can apply iterative deeping to give it Breadth-first search behavior.
      By combining a Priority Queue with a heuristic (a rule to approximate the best solution) we've added the search A* into our toolbox.
      Using a heap as our priority queue maximizes speed of the search, both insert and remove will have O(log(n)) time. However, A* has a problem of running into local maxes and local minimums. A techniqe called "simulated annealing" can be applied to attempt to dodge these maxima and minima.  
    </p>
    <br>
    <h3>Vocab</h3>
    <ul>
      <li>Iterative deepening</li>
      <li>Heuristic</li>
      <li>Routing algorithm</li>
      <li>Simulated annealing</li>
      <li>Hill climbing</li>
      <li>Dijkstra's algorithm</li>
    </ul>
    <h3> Quick Search Review</h3>
    <table border = "1">
      <tr>
	<th>Fontier Type</th>
	<th>Search Type</th>
	<th> <font color = "green">Advantage(s)</font> </th>
	<th> <font color =  "red">Disadvantage(s)</font></th>
      </tr>
      <tr>
	<th>Stack</th>
	<th>Depth-First Search</th>
	<th>Path is usually found quickly.</th>
	<th>The path found is inefficient.</th>
      </tr>
      <tr>
	<th>Queue</th>
	<th>Breadth-First Search</th>
	<th>Shortest path found.</th>
	<th>Explores several nodes.</th>
      </tr>
      <tr>
	<th>Priorty Queue</th>
	<th>A*</th>
	<th>Short path is found quickly.</th>
	<th>Requires a decent heuristic.<br> Can get caught on local maxes/mins.</th>
      </tr>
    </table>
<!--  </body>
</html> -->

